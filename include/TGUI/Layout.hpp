/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// TGUI - Texus' Graphical User Interface
// Copyright (C) 2012-2017 Bruno Van de Velde (vdv_b@tgui.eu)
//
// This software is provided 'as-is', without any express or implied warranty.
// In no event will the authors be held liable for any damages arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it freely,
// subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented;
//    you must not claim that you wrote the original software.
//    If you use this software in a product, an acknowledgment
//    in the product documentation would be appreciated but is not required.
//
// 2. Altered source versions must be plainly marked as such,
//    and must not be misrepresented as being the original software.
//
// 3. This notice may not be removed or altered from any source distribution.
//
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


#ifndef TGUI_LAYOUT_HPP
#define TGUI_LAYOUT_HPP

#include <SFML/System/Vector2.hpp>
#include <TGUI/Config.hpp>
#include <type_traits>
#include <string>

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

namespace tgui
{
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /// @brief Class to store the left, top, width or height of a widget
    ///
    /// You don't have to explicitly create an instance of this class, numbers and strings are implicitly cast.
    ///
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    class TGUI_API Layout
    {
    public:

        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        /// @brief Default constructor
        ///
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        constexpr Layout() :
            Layout{0}
        {
        }


        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        /// @brief Constructor to implicitly construct from numeric constant
        ///
        /// @param constant  Value of the layout
        ///
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        template <typename T, typename = typename std::enable_if<std::is_arithmetic<T>::value, T>::type>
        constexpr Layout(T constant) :
            m_constant{true},
            m_value   {static_cast<float>(constant)}
        {
        }


        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        /// @brief Construct the layout based on a string which will be parsed to determine the value of the layout
        ///
        /// @param expression  String to parse
        ///
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        Layout(const char* expression) :
            Layout{std::string{expression}}
        {
        }


        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        /// @brief Construct the layout based on a string which will be parsed to determine the value of the layout
        ///
        /// @param expression  String to parse
        ///
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        Layout(const std::string& expression)
        {
            if (!expression.empty() && (expression.back() == '%'))
            {
                m_constant = false;
                m_ratio    = std::stof(expression.substr(0, expression.length()-1)) / 100.f;
            }
            else
            {
                m_constant = true;
                m_value    = std::stof(expression.substr(0, expression.length()));
            }
        }


        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        /// @brief Returns the cached value of the layout
        ///
        /// @return Value of the layout
        ///
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        constexpr float getValue() const
        {
            return m_value;
        }


        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        /// @internal
        /// @brief Returns whether the value in the layout is constant
        ///
        /// @return Is the layout value constant?
        ///
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        constexpr bool isConstant() const
        {
            return m_constant;
        }


        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        /// @internal
        /// @brief Returns the ratio used by the layout
        ///
        /// @return Ratio of the parent size that defines the layout value
        ///
        /// This function should only be called when the layout does not contain a constant value.
        ///
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        constexpr float getRatio() const
        {
            return m_ratio;
        }


        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        /// @internal
        /// @brief Update the size to which the layout depends on if its value is relative
        ///
        /// @param newParentSize  New size from which to take the relative value
        ///
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        constexpr void updateParentSize(float newParentSize)
        {
            if (!m_constant)
            {
                m_parentValue = newParentSize;
                m_value = m_ratio * newParentSize;
            }
        }


        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    private:

        bool  m_constant    = true;
        float m_value       = 0;
        float m_ratio       = 0;
        float m_parentValue = 0;
    };


    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    /// @brief Class to store the position or size of a widget
    ///
    /// You don't have to explicitly create an instance of this class, sf::Vector2f is implicitly converted.
    ///
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    class TGUI_API Layout2d
    {
    public:

        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        /// @brief Default constructor to implicitly construct from an sf::Vector2f.
        ///
        /// @param constant  Value of the layout
        ///
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        Layout2d(sf::Vector2f constant = {0, 0}) :
            x{constant.x},
            y{constant.y}
        {
        }


        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        /// @brief Constructor to create the Layout2d from two Layout classes
        ///
        /// @param layoutX  x component
        /// @param layoutY  y component
        ///
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        Layout2d(Layout layoutX, Layout layoutY) :
            x{std::move(layoutX)},
            y{std::move(layoutY)}
        {
        }


        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        /// @brief Returns the cached value of the layout
        ///
        /// @return Value of the layout
        ///
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        sf::Vector2f getValue() const
        {
            return {x.getValue(), y.getValue()};
        }


        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        /// @internal
        /// @brief Update the size to which the layout depends on if its value is relative
        ///
        /// @param newParentSize  New size from which to take the relative value
        ///
        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        void updateParentSize(sf::Vector2f newParentSize)
        {
            x.updateParentSize(newParentSize.x);
            y.updateParentSize(newParentSize.y);
        }


        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    public:
        Layout x;
        Layout y;
    };

    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#endif // TGUI_LAYOUT_HPP
